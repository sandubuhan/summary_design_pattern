![image-20220510221400118](E:\重生之路\Geekbang\summary_design_pattern\笔记\总结（一）.assets\image-20220510221400118.png)

# 创建型

+ 单例模式，工厂模式，建造者模式，原型模式。解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码

## 单例模式

+ 创建全局唯一的对象。
+ 饿汉式，懒汉式，双重检测，静态内部类，枚举
+ 单例的缺点
    + 单例对OOP特性不友好
    + 会隐藏类之间的依赖关系
    + 单例对代码的扩展性不友好
    + 单例对代码的可测试性不友好
    + 不支持有参数的构造函数
+ 如果单例类没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题

## 工厂模式

+ 简单工厂、工厂方法、抽象工厂
+ 用来创建不同但是相关类型的对象（继承统一父类或者接口的一组子类），由给定的参数来决定创建那种类型的对象
+ 当创建逻辑比较复杂，是一个“大工程”的时候，可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离
+ 当每个对象的创建逻辑都比较简单的时候，使用简单工厂，将多个对象的创建逻辑放到一个工厂类中。
+ 当较复杂的时候，为了避免设计一个过于庞大的工厂类，推荐使用工厂方法模式，将创建逻辑拆分的更细，每个对象的创建逻辑独立到各自的工厂类中
+ 作用
    + 封装变化：创建逻辑有可能变化，封装成工厂类后，创建逻辑的变更对调用者更透明
    + 代码复用：创建代码抽离到独立的工厂类之后可以复用
    + 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
    + 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁
+ 工厂模式经典应用场景：依赖注入框架，Spring IOC等

## 建造者模式

+ 创建复杂对象，可以通过设置不同的可选参数，定制化的创建不同的对象。
+ 如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，可以通过构造函数配合set()方法来解决，但如果存在下面的任意一种，可以使用建造者模式
    + 当把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的就无处安放了
    + 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系活着约束条件的逻辑就无处安放了
    + 如果我们希望创建不可变对象，也就是当对象在创建好之后，就不能在修改内部的属性值，要实现这个功能，我们就不能在类中暴露set(方法，构造函数配合set方法来设置属性值的方式就不适用了

## 原型模式

+ 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段相同），在这种情况下，我们可以利用对已有对象（原型）进行复制的方式，来创建新对象，以达到节省创建时间的目的。
+ 深拷贝：得到的是一份完全独立的对象
+ 浅拷贝：只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归的复制引用对象，以及引用对象的引用对象
+ 操作非常耗时的情况下，推荐使用浅拷贝，否则一般使用深拷贝



# 结构型设计模式

+ 一些类或对象组合在一起的经典结构。

## 代理模式

+ 在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能。
+ 一般让代理类和原始类实现同样的接口，但是如果原始类没有定义接口，并且原始类代码并不是我们开发维护的，此时可以让代理类继承原始类的方法来实现代理模式
+ 静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。
+ 可以用动态代理来解决，不用实现为每个原始类编写代理类，而是在运行的时候动态的创建原始类对应的代理类，然后在系统中用代理类替换掉原始类
+ 代理模式常用在业务系统中开发一些非功能性需求，比如监控统计鉴权限流事务等。
+ 将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。还可用在RPC，缓存等应用场景中

## 桥接模式

+ 两种理解方式
+ 将抽象和实现解耦，让他们能独立开发
+ 组合优于继承设计原则。
+ 代码结构都是相同的，都是一种类之间的组合关系

## 装饰器模式

+ 主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否改用装饰器的一个重要依据
+ 特点：对原始类嵌套使用多个装饰器
+ 为了这个需求，在设计的时候，装饰器需要根据原始类继承相同的抽象类或者接口

## 适配器模式

+ 代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口，适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口
+ 类适配器：使用继承来实现
+ 对象适配器：使用组合来实现
+ 当出现接口不兼容时
    + 封装有缺陷的接口设计
    + 统一多个类的接口设计
    + 替换依赖的外部系统
    + 兼容老版本接口
    + 适配不同格式的数据

## 门面模式

+ 通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。

## 组合模式

+ “组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。
+ 组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。

## 享元模式

+ 所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
+ 具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。