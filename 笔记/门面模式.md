# 门面模式

+ 在开发中，为了保证接口的可复用性（通用性），我们需要将接口设计的细粒度一点，职责单一一点。但是如果粒度过小，就会导致需要调用n多细粒度的接口才能完成，调用者就会抱怨接口不好用
+ 如果粒度设计的太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好
+ 为了解决这种矛盾，可以使用门面模式

## 原理与实现

+ 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用
+ 假设B要调用A系统的三个接口，但是如果依次调用的话可能会导致A系统的相应速度比较慢，因为过多的接口调用过多的网络通信。可以利用门面欧辰，让后端服务器提供一个包裹这三个接口调用的接口x。然后B调用一次接口x，来获取数据，降低调用次数

## 场景问题

1. 解决易用性问题

+ 隐藏系统的复杂性，提供更加简单易用更高层的接口。比如Linux系统调用函数就可以看做预充门面。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。
+ 设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。

2. 解决性能问题

+ 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。

## 总结

+ 接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。
+ 适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。 门面模式做接口整合，解决的是多接口调用带来的问题。